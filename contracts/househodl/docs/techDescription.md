Our omnichain solution is comprised of two components. The first of which is our “master contract”, which is the oracle for all cross-chain data and that runs on a chain of our choice (in this case Ethereum). The master contract is responsible for tracking the member addresses and chains of each group, as well as tracking the “debt” balances that each member owes to other the group. The second component is deployed onto each chain where we allow staking, acting as a satellite of the master. This contract allows users to natively stake the token of their choice, on the chain of their choice. These tokens are immediately supplied to AAVE for yield. All gas fees for engaging with our staking contract are sponsored, but recovered from users who withdraw before we break even on their cost. When users interact with our solution, they interact with the local satellite contract where they’ve staked their tokens. These interactions are then passed back and forth to the master contract using LayerZero to message across chains. When a user with a positive “debt” balance wishes to withdraw from the system, we automatically borrow USDC from AAVE on behalf of members with a negative “debt” balance using their staked tokens in order to pay their share of the outstanding debt. The borrow APR is passed on directly to the member. Where possible, we should perform optimizations such as using the contract’s held USDC whilst continuing to charge the AAVE APR as a means of revenue collection. They then have an opportunity to either carry this balance (continuing to pay the borrow APR up till their collateralization ratio), sell a portion of their staked assets, or provide new USDC to settle their balance. Our solution allows our groups to maintain their exposure to the token of their choice on the chain of their choice, as well as earn APY from their staked token, only paying the borrow APR when absolutely required to make their group members whole. Trust is removed from the group finances, as all group members are required to be over-collateralized and required to settle with other group members before they can withdraw. When a user with a negative “debt” balance wishes to withdraw from the system, they are required to settle with other group members before they can withdraw. This can be achieved by selling their staked token, or providing new USDC. When users are made whole, USDC is used as the transfer currency. USDC is transferred via CCTP v2 to the chain where the user resides, and immediately supplied to AAVE. Users can choose to either withdraw or swap their positive balance into their stake token at any time, causing a call on any outstanding debts owed to them. We pocket the APY of any USDC balance not held as a staked token as a fee for management.

When a group member makes a transaction using fiat on behalf of the group, they register this transaction with the contract on their chain. This is messaged to the master contract. Each group member has an opportunity to vote to decline the transaction before the debt balance changes are locked in.

On the frontend, Dynamic is used to improve the accessibility to non crypto-natives. Users can onramp funds into embedded wallets, or connect their existing wallet to stake their funds into groups. The frontend makes RPC calls directly to the contracts, keeping all essential business flows on chain. As part of our user flows, we use AI off-chain to read information from receipts before supplying the details to the master contract in a transaction initiated using the Dynamic SDK.